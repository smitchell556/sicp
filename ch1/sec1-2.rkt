#lang scheme

;;; ===========
;;; Section 1.2
;;; ===========


;;; Exercise 1.9
;;; ------------
;;; Use the substitution model to illustrate the process generated by the
;;; following procedures evaluating (+ 4 5). Are the processes iterative or
;;; recursive?

(define (+ a b)
  (if (= a 0)
      b
      (inc (+ (dec a) b))))

(+ 4 5)
;; (inc (+ 3 5))
;; (inc (inc (+ 2 5)))
;; (inc (inc (inc (+ 1 5))))
;; (inc (inc (inc (inc (+ 0 5)))))
;; (inc (inc (inc (inc 5))))
;; (inc (inc (inc 6)))
;; (inc (inc 7))
;; (inc 8)
;; 9
;; This is a recursive process. The state is not saved from one step to the next
;; and is dependent on the call stack.

(define (+ a b)
  (if (= a 0)
      b
      (+ (dec a) (inc b))))

(+ 4 5)
;; (+ 3 6)
;; (+ 2 7)
;; (+ 1 8)
;; (+ 0 9)
;; 9
;; This is an iterative process. The state is saved from one step to the next
;; and is not dependent on the call stack. If the procedure is stopped, it can
;; be resumed with the same values the procedure's state contained upon
;; termination and the answer will still be correct.


;;; Exercise 1.10
;;; -------------
;;; Use the following procedure to answer the following questions.

(define (A x y)
  (cond ((= y 0) 0)
        ((= x 0) (* 2 y))
        ((= y 1) 2)
        (else (A (- x 1)
                 (A x (- y 1))))))

;;; What are the values of the following expressions?

(A 1 10)
;; (A 0 (A 1 9))
;; (A 0 (A 0 (A 1 8)))
;; (A 0 (A 0 (A 0 (A 1 7))))
;; (A 0 (A 0 (A 0 (A 0 (A 1 6)))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 5))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 4)))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 3))))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 2)))))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 1))))))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 2)))))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 4))))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 8)))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 16))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 32)))))
;; (A 0 (A 0 (A 0 (A 0 64))))
;; (A 0 (A 0 (A 0 128)))
;; (A 0 (A 0 256))
;; (A 0 512)
;; 1024

(A 2 4)
;; (A 1 (A 2 3))
;; (A 1 (A 1 (A 2 2)))
;; (A 1 (A 1 (A 1 (A 2 1))))
;; (A 1 (A 1 (A 1 2)))
;; (A 1 (A 1 (A 0 (A 1 1))))
;; (A 1 (A 1 (A 0 2)))
;; (A 1 (A 1 4))
;; (A 1 (A 0 (A 1 3)))
;; (A 1 (A 0 (A 0 (A 1 2))))
;; (A 1 (A 0 (A 0 (A 0 (A 1 1)))))
;; (A 1 (A 0 (A 0 (A 0 2))))
;; (A 1 (A 0 (A 0 4)))
;; (A 1 (A 0 8))
;; (A 1 16)
;; (A 0 (A 1 15))
;; (A 0 (A 0 (A 1 14)))
;; (A 0 (A 0 (A 0 (A 1 13))))
;; (A 0 (A 0 (A 0 (A 0 (A 1 12)))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 11))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 10)))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 9))))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 8)))))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 7))))))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 6)))))))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 5))))))))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 4)))))))))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 3))))))))))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 2)))))))))))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 1))))))))))))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 2)))))))))))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 4))))))))))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 8)))))))))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 16))))))))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 32)))))))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 64))))))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 128)))))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 256))))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 512)))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 1024))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 2048)))))
;; (A 0 (A 0 (A 0 (A 0 4096))))
;; (A 0 (A 0 (A 0 8192)))
;; (A 0 (A 0 16384))
;; (A 0 32768)
;; 65536

(A 3 3)
;; (A 2 (A 3 2))
;; (A 2 (A 2 (A 3 1)))
;; (A 2 (A 2 2))
;; (A 2 (A 1 (A 2 1)))
;; (A 2 (A 1 2))
;; (A 2 (A 0 (A 1 1)))
;; (A 2 (A 0 2))
;; (A 2 4)
;; (A 1 (A 2 3))
;; (A 1 (A 1 (A 2 2)))
;; (A 1 (A 1 (A 1 (A 2 1))))
;; (A 1 (A 1 (A 1 2)))
;; (A 1 (A 1 (A 0 (A 1 1))))
;; (A 1 (A 1 (A 0 2)))
;; (A 1 (A 1 4))
;; (A 1 (A 0 (A 1 3)))
;; (A 1 (A 0 (A 0 (A 1 2))))
;; (A 1 (A 0 (A 0 (A 0 (A 1 1)))))
;; (A 1 (A 0 (A 0 (A 0 2))))
;; (A 1 (A 0 (A 0 4)))
;; (A 1 (A 0 8))
;; (A 1 16)
;; (A 0 (A 1 15))
;; (A 0 (A 0 (A 1 14)))
;; (A 0 (A 0 (A 0 (A 1 13))))
;; (A 0 (A 0 (A 0 (A 0 (A 1 12)))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 11))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 10)))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 9))))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 8)))))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 7))))))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 6)))))))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 5))))))))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 4)))))))))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 3))))))))))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 2)))))))))))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 1))))))))))))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 2)))))))))))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 4))))))))))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 8)))))))))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 16))))))))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 32)))))))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 64))))))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 128)))))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 256))))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 512)))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 1024))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 2048)))))
;; (A 0 (A 0 (A 0 (A 0 4096))))
;; (A 0 (A 0 (A 0 8192)))
;; (A 0 (A 0 16384))
;; (A 0 32768)
;; 65536

;;; Consider the following procedures, where A is the procedure defined above,
;;; what are the mathematical definitions for the functions computed by the
;;; procedures f, g, and h?

(define (f n) (A 0 n))
;; (f n) = 2 * n

(define (g n) (A 1 n))
;; (g n) = 2^n

(define (h n) (A 2 n))
;; (h n) = 2^ * n or 2^(2^...(n-1 times)) (total of n 2's)


;;; Exercise 1.11
;;; -------------
;;; A function f is defined such that f(n) = n if n < 3 and f(n) = (fn-1) +
;;; 2 * f(n-2) + 3 * f(n-3) if n >= 3. Define recursive and iterative procedures
;;; for f.

;; Recursive
(define (f n)
  (cond
   ((< n 3) n)
   (else
    (+ (f (- n 1))
       (* 2
          (f (- n 2)))
       (* 3
          (f (- n 3)))))))

;; Iterative
(define (f n)
  (define (f-iter a b c count)
    (cond
     ((< n 3) n)
     (else (if (> count n)
               a
               (f-iter (+ a
                          (* 2 b)
                          (* 3 c))
                       a
                       b
                       (+ count 1))))))
  (f-iter 2 1 0 3))


;;; Exercise 1.12
;;; -------------
;;; Write a procedure that computes elements of Pascal's triangle by means of
;;; a recursive process.

(define (pascal n)
  (define (pascal-num-recur col row)    ; generate a pascal number
    (cond
     ((= row 0) 1)
     ((or (= col 0) (= col row)) 1)
     (else
      (+ (pascal-num-recur (- col 1) (- row 1))
         (pascal-num-recur col (- row 1))))))
  (define (pascal-iter col row)
    (cond
     ((<= col row)                      ; iterate through columns
      (printf "~a " (pascal-num-recur col row))
      (pascal-iter (+ col 1) row))
     ((< row (- n 1))                         ; iterate through rows
      (printf "\n")
      (pascal-iter 0 (+ row 1)))
     (else (printf "\n"))))
  (pascal-iter 0 0))

;; The question only asks to compute the elements, but I took it one step
;; further by printing all elements through n rows. Although there is an
;; iterative procedure `pascal-iter`, it's purpose is to step through each
;; element in pascal's triangle and print the result of `pascal-num-recur` for
;; that element in the triangle. `pascal-num-recur` is the procedure that
;; fulfills the exercise.


;;; Exercise 1.13
;;; -------------
;;; Prove Fib(n) is closest integer to x^n / sqrt(5) where x = (1 + sqrt(5)) / 2.
;;; Hint: Let y = (1 - sqrt(5)) / 2. Use induction and the definition of the
;;; Fibonacci numbers to prove Fib(n) = (x^n - y^n) / sqrt(5).

;; Note x^2 = x + 1 and by extension y^2 = y + 1

;; The base cases are:
;; Fib(0) = 0
;; Fib(1) = 1

;; The recursive case is:
;; Fib(n) = Fib(n-1) + Fib(n-2)

;; Proving the base cases

;; Computing x^n for the base case n = 0 results in:
;; n = 0; ((1 + sqrt(5)) / 2)^0 = 1
;; Computing y^n results in:
;; n = 0; ((1 - sqrt(5)) / 2)^0 = 1
;; Computing (x^n - y^n) / sqrt(5):
;; n = 0; (1 - 1) / sqrt(5) = 0
;; Fib(0) = (x^n - y^n) / sqrt(5) = 0     ; True

;; Computing x^n for the base case n = 1 results in:
;; n = 1; ((1 + sqrt(5)) / 2)^1 = (1 + sqrt(5)) * (1 / 2) =~ 1.618
;; Computing y^n results in:
;; n = 1; ((1 - sqrt(5)) / 2)^1 = (1 - sqrt(5)) * (1 / 2) =~ -0.618
;; Computing (x^n - y^n) / sqrt(5):
;; n = 1; ((1 + sqrt(5)) * (1 / 2) - (1 - sqrt(5)) * (1 / 2)) / sqrt(5) = 1
;; Fib(1) = (x^n - y^n) / sqrt(5) = 1     ; True

;; Proving the recursive case

;; Assume the statements Fib(0) through Fib(n-1) are true for
;; Fib(m) = (x^m - y^m) / sqrt(5), prove Fib(n) = (x^n - y^n) / sqrt(5) is true.

;; Fib(n) = (x^n - y^n) / sqrt(5)
;; Fib(n) = Fib(n-1) + Fib(n-2)
;; = ((x^(n-1) - y^(n-1)) / sqrt(5)) + ((x^(n-2) - y^(n-2)) / sqrt(5))
;; = ((x^n / x) - (y^n / y) + (x^n / x^2) - (y^n / y^2)) / sqrt(5)
;; = (x^n * ((1 / x) + (1 / x^2)) - y^n * ((1 / y) + (1 / y^2))) / sqrt(5)
;; = (x^n * ((x + 1) / x^2) - y^n * ((y + 1) / y^2)) / sqrt(5)
;; = (x^n * (x^2 / x^2) - y^n * (y^2 / y^2)) / sqrt(5)
;; = (x^n - y^n) / sqrt(5)
;; Therefore Fib(n) is true and holds true for all n > 1.

;; Now to prove Fib(n) is the closest integer to x^n / sqrt(5). Since Fib(n) =
;; (x^n - y^n) / sqrt(5), we must show that -1/2 < y^n / sqrt(5) < 1/2 or
;; abs(y^n / sqrt(5)) < 1/2 for all n >= 0. This shows x^n / sqrt(5) is closer
;; to Fib(n) than it would be to Fib(n) + 1 or Fib(n) - 1.

;; Since y = (1 - sqrt(5)) / 2, y^n / sqrt(5) will be represented as
;; (1 - sqrt(5))^n / (2^n * sqrt(5))

;; First we prove the base case n = 0.
;; n = 0; abs((1 - sqrt(5))^0 / (2^0 * sqrt(5))) = 1 / sqrt(5) =~ 0.447
;; 1 / sqrt(5) < 1/2 is true.

;; Next we prove that abs(y^n / sqrt(5)) < abs(y^(n-1) / sqrt(5)). The
;; constants can be removed and all that needs to be proved is that
;; abs(y^n) < abs(y^(n-1))

;; Expanding y^n and y^(n-1) we get
;; abs((1 - sqrt(5))^n / 2^n) < abs((1 - sqrt(5))^(n-1) / 2^(n-1))
;; Using arithmetic results in
;; abs((1 - sqrt(5))^n / (1 - sqrt(5))^(n-1)) < abs(2^n / 2^(n-1))
;; which can be reduced to abs(1 - sqrt(5)) < abs(2) which is true.

;; Therefore as n increases, the value of abs(y^n / sqrt(5)) decreases. Since
;; abs(y^n / sqrt(5)) < 1/2 when n = 0, then abs(y^n / sqrt(5)) < 1/2 for all
;; n > 0. Since we've proved that -1/2 < y^n / sqrt(5) < 1/2 for all n >= 0,
;; it holds true that Fib(n) is the closest integer to x^n / sqrt(5) for all
;; n > 0.


;;; Exercise 1.14
;;; -------------
;;; Draw the tree illustrating the process generated by the count-change
;;; procedure for making change from 11 cents. What are the orders of growth
;;; of space and number of stpes used by this process as the amount increases?

(define (count-change amount)
  (cc amount 5))

(define (cc amount kinds-of-coins)
  (cond ((= amount 0) 1)
        ((or (< amount 0) (= kinds-of-coins 0)) 0)
        (else (+ (cc amount
                     (- kinds-of-coins 1))
                 (cc (- amount
                        (first-denomination kinds-of-coins))
                     kinds-of-coins)))))

(define (first-denomination kinds-of-coins)
  (cond ((= kinds-of-coins 1) 1)
        ((= kinds-of-coins 2) 5)
        ((= kinds-of-coins 3) 10)
        ((= kinds-of-coins 4) 25)
        ((= kinds-of-coins 5) 50)))

;; Note: Leaves resulting in a 0 return value are not shown in the tree.

;; Nodes are represented as <amount> (<kinds-of-coins>)
;;               11 (50, 25, 10, 5, 1)
;;                         |
;;                 11 (25, 10, 5, 1)
;;                         |
;;                   11 (10, 5, 1)
;;                /                 \
;;           11 (5, 1)          1 (10, 5, 1)
;;         /          \              |
;;      11 (1)     6 (5, 1)       1 (5, 1)
;;        |        /      \          |
;;      10 (1)   6 (1)  1 (5, 1)   1 (1)
;;        |        |      |          |
;;       9 (1)   5 (1)   1 (1)     0 (1)
;;        |        |      |
;;       8 (1)   4 (1)   0 (1)
;;        |        |
;;       7 (1)   3 (1)
;;        |        |
;;       6 (1)   2 (1)
;;        |        |
;;       5 (1)   1 (1)
;;        |        |
;;       4 (1)   0 (1)
;;        |
;;       3 (1)
;;        |
;;       2 (1)
;;        |
;;       1 (1)
;;        |
;;       0 (1)

;; =~ 55 total nodes
;; TBC after learning more about algorithmic analysis


;;; Exercise 1.15
;;; -------------
;;; The sine of an angle (in radians) can be computed by making use of the
;;; approximation sin x =~ x if x is sufficiently small and the identity
;;; sin x = 3 * sin (x/3) - 4 * sin^3 (x/3) to reduce the size of the argument
;;; of sin. Sufficiently small is magnitude less than 0.1 radians.

(define (cube x) (* x x x))

(define (p x) (- (* 3 x) (* 4 (cube x))))

(define (sine angle)
  (if (not (> (abs angle) 0.1))
      angle
      (p (sine (/ angle 3.0)))))

;;; a) How many times is the procedure p applied when (sine 12.15) is
;;;    evaluated?

;; (sine 12.15)
;; (p (sine 4.05))
;; (p (p (sine 1.35)))
;; (p (p (p (sine 0.45))))
;; (p (p (p (p (sine 0.15)))))
;; (p (p (p (p (p (sine 0.05))))))

;; p is called 5 times.

;;; b) What is the order of growth in space and number of steps (as a function
;;;    of a) used by the process generated by the sine procedure when (sine a)
;;;    is evaluated?

;; TBC after learning more about algorithmic analysis


;;; Exercise 1.16
;;; -------------
;;; Create an iterative process for exponentiation that uses successive
;;; squaring and uses a logarithmic number of steps.

(define (fast-expt b n)
  (define (fast-expt-iter b n a)
    (cond ((= n 1) a)
          ((even? n) (fast-expt-iter b
                                     (/ n 2)
                                     (* a (square b))))
          (else (fast-expt-iter b
                                (- n 1)
                                (* a b)))))
  (fast-expt-iter b n 1))


;;; Exercise 1.17
;;; -------------
;;; Create a faster multiplication procedure using `double` and `halve`
;;; that uses a logarithmic number of steps.

(define (double n)
  (+ n n))

(define (halve n)
  (/ n 2))

(define (fast-mult a b)
  (cond
   ((= b 0) 0)
   ((even? b) (double (fast-mult a (halve b))))
   (else
    (+ a (fast-mult a (- b 1))))))


;;; Exercise 1.18
;;; -------------
;;; Create an iterative process for multiplying two integers in terms of
;;; adding, doubling, and halving and uses logarithmic number of steps.

(define (fast-mult a b)
  (define (fast-mult-iter n rv)
    (cond
     ((null? n) rv)
     ((even? (car n)) (fast-mult-iter (cdr n) (double rv)))
     (else
      (fast-mult-iter (cdr n) (+ a rv)))))
  (define (n-list n)
    (cond
     ((= (car n) 2) n)
     ((even? (car n)) (n-list (cons (halve (car n)) n)))
     (else
      (n-list (cons (- (car n) 1) n)))))
  (cond
   ((or (= a 0) (= b 0)) 0)
   ((= a 1) b)
   ((= b 1) a)
   (else
    (fast-mult-iter (n-list (list b)) a))))

;; Struggled with this one. The book hasn't touched on lists yet, but I couldn't
;; come up with a way to iterate up from a starting value of `a` without knowing
;; where to double beforehand. May come back to this one.


;;; Exercise 1.19
;;; -------------
;;; Compute p' and q' for the modified fibonacci process.

(define (fib n)
  (fib-iter 1 0 0 1 n))
(define (fib-iter a b p q count)
  (cond ((= count 0) b)
        ((even? count) (fib-iter a
                                 b
                                 (p-prime p q)
                                 (q-prime p q)
                                 (/ count 2)))
        (else (fib-iter (+ (* b q) (* a q) (* a p))
                        (+ (* b p) (* a q))
                        p
                        q
                        (- count 1)))))

;; Using the transformation T(pq) = {a = bq+aq+ap, b = bp+aq} to find T(p'q')
;; by performing the transformation twice such that T(T(pq)) = T(p'q'). Solve
;; for p' and q'.

(define (p-prime p q)
  (+ (* p p) (* q q)))

(define (q-prime p q)
  (+ (* q q) (* 2 p q)))


;;; Exercise 1.20
;;; -------------
;;; Evaluate the number of remainder operations for the gcd procedure using
;;; normal-order evaluation and applicative-order evaluation

(define (gcd a b)
  (if (= b 0)
      a
      (gcd b (remainder a b))))

;; Using normal-order evaluation
(gcd 206 40)

;; recursively calls
(gcd 40 (remainder 206 40))
;; b = 6

;; where b = (remainder 206 40) is not expanded until b is needed as a primitive
;; value. So b is expanded when compared to 0. Otherwise the remainder procedure
;; continues to be passed around as is repeatedly building on itself. It is then
;; expanded when b = 0 and a is returned.
(gcd (remainder 206 40) (remainder 40 (remainder 206 40)))
;; b = 4
(gcd (remainder 40 (remainder 206 40))
     (remainder (remainder 206 40) (remainder 40 (remainder 206 40))))
;; b = 2
(gcd (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))
     (remainder (remainder 40 (remainder 206 40))
                (remainder (remainder 206 40) (remainder 40 (remainder 206 40)))))
;; b = 0, calculate a and return.
(remainder (remainder 206 40) (remainder 40 (remainder 206 40)))
(remainder 6 (remainder 40 (remainder 206 40)))
(remainder 6 (remainder 40 6))
(remainder 6 4)
2

;; The number of times b was evaluated to check for equality with 0 was 14 times
;; since with every level deeper the number of calls to remainder increases. Then
;; a was evaluated at the end which made 4 calls to remainder resulting in a total
;; of 18 calls to remainder.

;; Using applicative-order evaluation
(gcd 206 40)
;; b = 6. b is expanded before being passed into the next gcd call and therefore
;; won't be repeatedly recalculated. This holds for each step.
(gcd 40 6)
(gcd 6 4)
(gcd 4 2)
(gcd 2 0)
2

;; The number of times remainder was called is equal to the number of times
;; b != 0, which is 4 times in this case. Therefore remainder was called 4
;; times.


;;; Exercise 1.21
;;; -------------
;;; Use smallest-divisor procedure to find the smallest divisor of 199, 1999,
;;; and 19999.

(define (smallest-divisor n)
  (find-divisor n 2))
(define (find-divisor n test-divisor)
  (cond ((> (square test-divisor) n) n)
        ((divides? test-divisor n) test-divisor)
        (else (find-divisor n (+ test-divisor 1)))))
(define (divides? a b)
  (= (remainder b a) 0))
(define (square n)
  (* n n))

(smallest-divisor 199)
;; 199

(smallest-divisor 1999)
;; 1999

(smallest-divisor 19999)
;; 7


;;; Exercise 1.22
;;; -------------
;;; Use timed-prime-test, write a procedure search-for-primes to find the three
;;; smallest primes larger than 1000, 10000, 100000, and 1000000. Compare the
;;; times to see if the theta(sqrt(n))analysis of the prime-test algorithm
;;; holds true.

(define (timed-prime-test n)
  (newline)
  (display n)
  (start-prime-test n (runtime))
  (newline))
(define (start-prime-test n start-time)
  (if (prime? n)
      (report-prime (- (runtime) start-time))))
(define (report-prime elapsed-time)
  (display " *** ")
  (display elapsed-time))
(define (smallest-divisor n)
  (find-divisor n 2))
(define (find-divisor n test-divisor)
  (cond ((> (square test-divisor) n) n)
        ((divides? test-divisor n) test-divisor)
        (else (find-divisor n (+ test-divisor 1)))))
(define (divides? a b)
  (= (remainder b a) 0))
(define (square n)
  (* n n))
(define (prime? n)
  (= n (smallest-divisor n)))

(define (search-for-primes n)
  (define (s-f-p n cnt)
    (cond ((> cnt 0) (s-f-p (+ 1 n)
                            (prime-test n cnt)))))
  (define (prime-test n cnt)
    (cond ((not (prime? n)) cnt)
          (else (timed-prime-test n)
                (- cnt 1))))
  (s-f-p n 3))

(search-for-primes 1000)
;; 1009 *** 7
;; 1013 *** 4
;; 1019 *** 6

(search-for-primes 10000)
;; 10007 *** 15
;; 10009 *** 11
;; 10037 *** 11

(search-for-primes 100000)
;; 100003 *** 36
;; 100019 *** 33
;; 100043 *** 32

(search-for-primes 1000000)
;; 1000003 *** 105
;; 1000033 *** 101
;; 1000037 *** 99

;; Analyzing the above results using the equation:
;; sqrt(n1) / sqrt(n2) = t1 / t2
;; should result in times being roughly equivalent to those above assuming
;; that the only thing affecting the time is the algorithm itself.
;; When using the above values of n, the tightness of the theta(sqrt(n))
;; analysis was stronger for values of n that were closer in magnitude. As n2
;; increased, the computed t2 based on the experimental t1 tended to increase
;; at a larger rate than the experimental t2, but it seemed to be by some
;; constant factor, which points toward an asymptotic bound. Based on the data
;; set created above it is difficult to claim that the running time is
;; proportional to the number of steps needed for computation, but it does lead
;; credence to a level of proportionality between the running time and the
;; number of steps needed.


;;; Exercise 1.23
;;; -------------
;;; Write a procedure `next` that returns 3 if its input is equal to 2 or
;;; increments the input by 2 otherwise. This cuts down on the redundant
;;; checks of even numbers. Run the same analysis as above and check if the
;;; running times are halved.

(define (timed-prime-test n)
  (newline)
  (display n)
  (start-prime-test n (runtime))
  (newline))
(define (start-prime-test n start-time)
  (if (prime? n)
      (report-prime (- (runtime) start-time))))
(define (report-prime elapsed-time)
  (display " *** ")
  (display elapsed-time))
(define (smallest-divisor n)
  (find-divisor n 2))
(define (find-divisor n test-divisor)
  (cond ((> (square test-divisor) n) n)
        ((divides? test-divisor n) test-divisor)
        (else (find-divisor n (next test-divisor))))) ; use `next` here.
(define (divides? a b)
  (= (remainder b a) 0))
(define (square n)
  (* n n))
(define (prime? n)
  (= n (smallest-divisor n)))
(define (search-for-primes n)
  (define (s-f-p n cnt)
    (cond ((> cnt 0) (s-f-p (+ 1 n)
                            (prime-test n cnt)))))
  (define (prime-test n cnt)
    (cond ((not (prime? n)) cnt)
          (else (timed-prime-test n)
                (- cnt 1))))
  (s-f-p n 3))

(define (next inp)
  (if (> inp 2)
      (+ inp 2)
      3))

(search-for-primes 1000)
;; 1009 *** 5
;; 1013 *** 2
;; 1019 *** 2

(search-for-primes 10000)
;; 10007 *** 11
;; 10009 *** 8
;; 10037 *** 6

(search-for-primes 100000)
;; 100003 *** 24
;; 100019 *** 20
;; 100043 *** 19

(search-for-primes 1000000)
;; 1000003 *** 65
;; 1000033 *** 60
;; 1000037 *** 62

;; The new algorithm runs at =~ 1.5x faster, which is different from the
;; expected value of 2. Again, the data set is much too small using a very
;; limited value of n to come to any significant conclusion, but if I were to
;; hazard a guess, the discrepency is due to the constant factors (conditional
;; checks, arithmetic, etc). 


;;; Exercise 1.24
;;; -------------
;;; Repeat the process for Exercise 1.23 using `fast-prime?`.

(define (timed-prime-test n)
  (newline)
  (display n)
  (start-prime-test n (runtime))
  (newline))
(define (start-prime-test n start-time)
  (if (fast-prime? n 100)
      (report-prime (- (runtime) start-time))))
(define (report-prime elapsed-time)
  (display " *** ")
  (display elapsed-time))
(define (square n)
  (* n n))
(define (search-for-primes n)
  (define (s-f-p n cnt)
    (cond ((> cnt 0) (s-f-p (+ 1 n)
                            (prime-test n cnt)))))
  (define (prime-test n cnt)
    (cond ((not (fast-prime? n 100)) cnt)
          (else (timed-prime-test n)
                (- cnt 1))))
  (s-f-p n 3))

(define (expmod base exp m)
  (cond ((= exp 0) 1)
        ((even? exp)
         (remainder (square (expmod base (/ exp 2) m))
                    m))
        (else
         (remainder (* base (expmod base (- exp 1) m))
                    m))))
(define (fermat-test n)
  (define (try-it a)
    (= (expmod a n n) a))
  (try-it (+ 1 (random (- n 1)))))
(define (fast-prime? n times)
  (cond ((= times 0) true)
        ((fermat-test n) (fast-prime? n (- times 1)))
        (else false)))

(search-for-primes 1000)
;; 1009 *** 258
;; 1013 *** 256
;; 1019 *** 260

(search-for-primes 10000)
;; 10007 *** 316
;; 10009 *** 244
;; 10037 *** 261

(search-for-primes 100000)
;; 100003 *** 349
;; 100019 *** 327
;; 100043 *** 352

(search-for-primes 1000000)
;; 1000003 *** 477
;; 1000033 *** 363
;; 1000037 *** 428

;; I chose an arbitrary number of 100 checks for the `fast-prime?` procedure,
;; and the results were wildly inconsistent. The above run times were the most
;; consistently observed of the minimal runs done, but even they would vary
;; by 20% or more. Looking at the above results, there's definitely a log(n)
;; trend since the run time increases roughly by a factor of log_2(10) for each
;; 10x magnitude increase.

;; The resulting run times were also much slower than the previous exercises.
;; Maybe because fast-prime? is run 100 times?
